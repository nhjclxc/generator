package repository

import (
    "context"
    "errors"
    "fmt"
    "gorm.io/gorm"
    "log/slog"
    "time"
)

// ${ClassName}Repository ${functionName} 结构体持久层
// @author ${author}
// @date ${datetime}
type ${ClassName}Repository struct {
    db *gorm.DB
}

// New${ClassName}Repository 创建 ${ClassName} ${functionName} 持久层对象
func New${ClassName}Repository(db *gorm.DB) *${ClassName}Repository {
    return &${ClassName}Repository{
        db: db,
    }
}

// 由于有时需要开启事务，因此 DB *gorm.DB 可以选择从外部传入

// Insert${ClassName} 新增${functionName}
func (repo *${ClassName}Repository) Insert${ClassName}(ctx context.Context, ${className} *model.${ClassName}) (int, error) {
    slog.Info("${ClassName}Repository.Insert${ClassName}：", slog.Any("${className}", ${className}))

    result := repo.db.WithContext(ctx).Model(&model.${ClassName}{}).Create(&${className})

    if result.Error != nil {
        return 0, fmt.Errorf("${ClassName}Repository.Insert${ClassName}Create, 新增失败: %w ", result.Error)
    }
    return int(result.RowsAffected), nil
}

// BatchInsert${ClassName}s 批量新增${functionName}
func (repo *${ClassName}Repository) BatchInsert${ClassName}s(ctx context.Context, ${className}s []*model.${ClassName}) (int, error) {
    slog.Info("${ClassName}Repository.BatchInsert${ClassName}s：", slog.Any("${className}s", ${className}s))

    result := repo.db.WithContext(ctx).Model(&model.${ClassName}{}).Create(&${className}s)
    if result.Error != nil {
        return 0, fmt.Errorf("${ClassName}Repository.BatchInsert${ClassName}s.Create, 新增失败: %w ", result.Error)
    }
    return int(result.RowsAffected), nil
}

// Update${ClassName}By${pkColumn.capJavaField} 根据主键修改${functionName}的所有字段
func (repo *${ClassName}Repository) Update${ClassName}By${pkColumn.capJavaField}(ctx context.Context, ${className} *model.${ClassName}) (int, error) {
    slog.Info("${ClassName}Repository.Update${ClassName}By${pkColumn.capJavaField}：", slog.Any("${className}", ${className}))

    //保存整个结构体（全字段更新）
    result := repo.db.WithContext(ctx).Model(&model.${ClassName}{}).Save(${className})
    if result.Error != nil {
        return 0, fmt.Errorf("${ClassName}Repository.Update${ClassName}By${pkColumn.capJavaField}.Save, 修改失败: %w ", result.Error)
    }
    return int(result.RowsAffected), nil
}

// Update${ClassName}Selective 修改${functionName}不为默认值的字段
func (repo *${ClassName}Repository) Update${ClassName}Selective(ctx context.Context, updateColumns []string, ${className} *model.${ClassName}) (int, error) {
    slog.Info("${ClassName}Repository.Update${ClassName}Selective：", slog.Any("${className}", ${className}))

    if len(updateColumns) == 0 {
        updateColumns = []string{#foreach($column in $columns)#if($column.columnName != ${pkColumn.columnName})"$column.columnName", #end#end}
    }
    // repo.db.WithContext(ctx).Model(&model.${ClassName}{}).Updates()：只更新指定字段
    result := repo.db.WithContext(ctx).Model(&model.${ClassName}{}).
        Where("${pkColumn.columnName} = ?", ${className}.${pkColumn.capJavaField}).
        Select(updateColumns).
        Updates(${className})
    if result.Error != nil {
        return 0, fmt.Errorf("${ClassName}Repository.Update${ClassName}Selective.Updates, 选择性修改失败: %w ", result.Error)
    }

    return int(result.RowsAffected), nil
}

// BatchUpdate${ClassName}Selective 批量修改${functionName}
func (repo *${ClassName}Repository) BatchUpdate${ClassName}Selective(ctx context.Context, updateColumns []string, ${className}s []model.${ClassName}) error {
    if len(updateColumns) == 0 {
        updateColumns = []string{#foreach($column in $columns)#if($column.columnName != ${pkColumn.columnName})"$column.columnName", #end#end}
    }
    return repo.db.WithContext(ctx).Model(&model.${ClassName}{}).Transaction(func(tx *gorm.DB) error {
        for _, v := range ${className}s {
            err := tx.Model(&model.${ClassName}{}).Where("${pkColumn.columnName} = ?", v.${pkColumn.capJavaField}).Select(updateColumns).Updates(v).Error
            if err != nil {
                return err // 触发回滚
            }
        }
        return nil // 提交事务
    })
}

// BatchDelete${ClassName}ByState 批量软删除 ${functionName}
func (repo *${ClassName}Repository) BatchDelete${ClassName}ByState(ctx context.Context, ${pkColumn.javaField}List []int64) error {
    slog.Info("${ClassName}Repository.BatchDelete${ClassName}ByState：", slog.Any("${pkColumn.javaField}List", ${pkColumn.javaField}List))

    return repo.db.WithContext(ctx).Model(&model.${ClassName}{}).Model(&model.${ClassName}{}).
        Where("${pkColumn.columnName} IN ?", ${pkColumn.javaField}List).
        Updates(map[string]any{
            "state":      0,
            "deleted_at": time.Now(),
        }).Error
}

// BatchDelete${ClassName} 根据主键批量删除 ${functionName}
func (repo *${ClassName}Repository) BatchDelete${ClassName}(ctx context.Context, ${pkColumn.javaField}List []int64) (int, error) {
    slog.Info("${ClassName}Repository.BatchDelete${ClassName}：", slog.Any("${pkColumn.javaField}List", ${pkColumn.javaField}List))

    // 当存在DeletedAt gorm.DeletedAt字段时为软删除，否则为物理删除
    result := repo.db.WithContext(ctx).Model(&model.${ClassName}{}).Where("${pkColumn.columnName} IN ?", ${pkColumn.javaField}List).Delete(&model.${ClassName}{})
    // result := repo.db.WithContext(ctx).Model(&model.${ClassName}{}).Model(&model.${ClassName}{}).Where("${pkColumn.columnName} IN ?", ${pkColumn.javaField}List).Update("state", 0)
    if result.Error != nil {
        return 0, fmt.Errorf("${ClassName}Repository.BatchDelete${ClassName}.Delete, 删除失败: %w ", result.Error)
    }

    //// 以下使用的是物理删除
    //result := repo.db.WithContext(ctx).Model(&model.${ClassName}{}).Unscoped().Delete(&model.${ClassName}{}, "${pkColumn.columnName} IN ?", ${pkColumn.javaField}List)
    //if result.Error != nil {
    //	return 0, fmt.Errorf("${ClassName}Repository.BatchDelete${ClassName}.Delete, 删除失败: %w ", result.Error)
    //}

    return int(result.RowsAffected), nil
}

// Find${ClassName}By${pkColumn.capJavaField} 获取${functionName}详细信息
func (repo *${ClassName}Repository) Find${ClassName}By${pkColumn.capJavaField}(ctx context.Context, ${pkColumn.javaField} int64) (*model.${ClassName}, error) {
    slog.Info("${ClassName}Repository.Find${ClassName}By${pkColumn.capJavaField}：", slog.Any("${pkColumn.javaField}", ${pkColumn.javaField}))

    ${className} := model.${ClassName}{}
    err := repo.db.WithContext(ctx).Model(&model.${ClassName}{}).First(&${className}, "${pkColumn.columnName} = ?", ${pkColumn.javaField}).Error
    return &${className}, err
}

// Find${ClassName}sBy${pkColumn.capJavaField}List 根据主键批量查询${functionName}详细信息
func (repo *${ClassName}Repository) Find${ClassName}sBy${pkColumn.capJavaField}List(ctx context.Context, ${pkColumn.javaField}List []int64) ([]*model.${ClassName}, error) {
    slog.Info("${ClassName}Repository.Find${ClassName}sBy${pkColumn.capJavaField}List：", slog.Any("${pkColumn.javaField}List", ${pkColumn.javaField}List))

    var result []*model.${ClassName}
    err := repo.db.WithContext(ctx).Model(&model.${ClassName}{}).Where("${pkColumn.javaField} IN ?", ${pkColumn.javaField}List).Find(&result).Error
    return result, err
}

// Select${ClassName}Unique 查询${functionName}的唯一记录
func (repo *${ClassName}Repository) Select${ClassName}Unique(ctx context.Context, ${className} model.${ClassName}) (*model.${ClassName}, error) {
    slog.Info("${ClassName}Repository.Select${ClassName}Unique：", slog.Any("${className}", ${className}))

    var temp model.${ClassName}
    query := repo.db.WithContext(ctx).Model(&model.${ClassName}{})

// 构造查询条件
#foreach($column in $columns)
    #set($queryType=$column.queryType)
    #set($columnName=$column.columnName)
    #if($column.query)
        #set($tags = "=")
        #if($column.queryType == "EQ")
            #set($tags = "=")
        #elseif($queryType == "NE")
            #set($tags = "!=")
        #elseif($queryType == "GT")
            #set($tags = ">")
        #elseif($queryType == "GTE")
            #set($tags = ">=")
        #elseif($queryType == "LT")
            #set($tags = "<")
        #elseif($queryType == "LTE")
            #set($tags = "<=")
        #elseif($queryType == "LIKE")
            #set($tags = "LIKE")
        #elseif($queryType == "BETWEEN")
        #end
        #set($defaultValue = '""')
        #if($column.goType == "string")
            #set($defaultValue = '""')
        #elseif($column.goType.contains("int"))
            #set($defaultValue = 0)
        #elseif($column.goType.contains("float"))
            #set($defaultValue = 0.0)
        #end
        #if($column.goType == 'time.Time')
        if !${className}.${column.goField}.IsZero() {
        query = query.Where("$columnName $tags ?", ${className}.$column.goField)
        // query = query.Where("DATE($columnName) $tags ?", ${className}.$column.goField.Format("2006-01-02"))
        }
        #else
        if ${className}.$column.goField != $defaultValue { query = query.Where("$columnName $tags ?",#if($tags == "LIKE") "%" + ${className}.$column.goField + "%"#else ${className}.$column.goField #end) }
        #end
    #end
#end

    tx := query.First(&temp)
    if tx.Error != nil {
        if errors.Is(tx.Error, gorm.ErrRecordNotFound) {
            // 没有数据，返回 nil
            return nil, nil
        }
        // 其他错误，直接返回
        return nil, tx.Error
    }

    // 找到数据，返回对象
    return &temp, nil
}

// Find${ClassName}List 查询${functionName}列表
func (repo *${ClassName}Repository) Find${ClassName}List(ctx context.Context, ${className} model.${ClassName}, startTime time.Time, endTime time.Time) ([]*model.${ClassName}, error) {
    slog.Info("${ClassName}Repository.Find${ClassName}List：", slog.Any("${className}", ${className}))

    var ${className}s []*model.${ClassName}
    query := repo.db.WithContext(ctx).Model(&model.${ClassName}{})

    // 构造查询条件
#foreach($column in $columns)
#set($queryType=$column.queryType)
#set($columnName=$column.columnName)
#if($column.query)
    #set($tags = "=")
    #if($column.queryType == "EQ")
        #set($tags = "=")
    #elseif($queryType == "NE")
        #set($tags = "!=")
    #elseif($queryType == "GT")
        #set($tags = ">")
    #elseif($queryType == "GTE")
        #set($tags = ">=")
    #elseif($queryType == "LT")
        #set($tags = "<")
    #elseif($queryType == "LTE")
        #set($tags = "<=")
    #elseif($queryType == "LIKE")
        #set($tags = "LIKE")
    #elseif($queryType == "BETWEEN")
    #end
    #set($defaultValue = '""')
    #if($column.goType == "string")
        #set($defaultValue = '""')
    #elseif($column.goType.contains("int"))
        #set($defaultValue = 0)
    #elseif($column.goType.contains("float"))
        #set($defaultValue = 0.0)
    #end
    #if($column.goType == 'time.Time')
    if !${className}.${column.goField}.IsZero() {
        query = query.Where("$columnName $tags ?", ${className}.$column.goField)
        // query = query.Where("DATE($columnName) $tags ?", ${className}.$column.goField.Format("2006-01-02"))
    }
    #else
    if ${className}.$column.goField != $defaultValue { query = query.Where("$columnName $tags ?",#if($tags == "LIKE") "%" + ${className}.$column.goField + "%"#else ${className}.$column.goField #end) }
    #end
#end
#end

    if !startTime.IsZero() {
        query = query.Where("created_at >= ?", startTime)
    }
    if !endTime.IsZero() {
        query = query.Where("created_at <= ?", endTime)
    }

    err := query.Find(&${className}s).Error
    return ${className}s, err
}

// Find${ClassName}PageList 分页查询${functionName}列表
func (repo *${ClassName}Repository) Find${ClassName}PageList(ctx context.Context, ${className} *model.${ClassName}, startTime time.Time, endTime time.Time, pageNum int, pageSize int) ([]*model.${ClassName}, int64, error) {
    slog.Info("${ClassName}Repository.Find${ClassName}PageList：", slog.Any("${className}", ${className}))

    var (
        ${className}s []*model.${ClassName}
        total     int64
    )

    query := repo.db.WithContext(ctx).Model(&model.${ClassName}{})

    // 构造查询条件
#foreach($column in $columns)
#set($queryType=$column.queryType)
#set($columnName=$column.columnName)
#if($column.query)
    #set($tags = "=")
    #if($column.queryType == "EQ")
        #set($tags = "=")
    #elseif($queryType == "NE")
        #set($tags = "!=")
    #elseif($queryType == "GT")
        #set($tags = ">")
    #elseif($queryType == "GTE")
        #set($tags = ">=")
    #elseif($queryType == "LT")
        #set($tags = "<")
    #elseif($queryType == "LTE")
        #set($tags = "<=")
    #elseif($queryType == "LIKE")
        #set($tags = "LIKE")
    #elseif($queryType == "BETWEEN")
    #end
    #set($defaultValue = '""')
    #if($column.goType == "string")
        #set($defaultValue = '""')
    #elseif($column.goType.contains("int"))
        #set($defaultValue = 0)
    #elseif($column.goType.contains("float"))
        #set($defaultValue = 0.0)
    #end
    #if($column.goType == 'time.Time')
    if !${className}.${column.goField}.IsZero() {
        query = query.Where("$columnName $tags ?", ${className}.$column.goField)
        // query = query.Where("DATE($columnName) $tags ?", ${className}.$column.goField.Format("2006-01-02"))
    }
    #else
    if ${className}.$column.goField != $defaultValue { query = query.Where("$columnName $tags ?",#if($tags == "LIKE") "%" + ${className}.$column.goField + "%"#else ${className}.$column.goField #end) }
    #end
#end
#end

    if !startTime.IsZero() {
        query = query.Where("created_at >= ?", startTime)
    }
    if !endTime.IsZero() {
        query = query.Where("created_at <= ?", endTime)
    }

    // 分页参数默认值
    if pageNum <= 0 {
        pageNum = 1
    }
    if pageSize <= 0 {
        pageSize = 10
    }

    // 先统计总数，Session()创建新会话防止Count()破坏Order()、Preload()、Group()等等
    err := query.Session(&gorm.Session{}).Count(&total).Error
    if err != nil {
        return nil, 0, err
    }

    // 再进行分页查询
    err = query.Limit(pageSize).Offset((pageNum - 1) * pageSize).Order("${pkColumn.columnName} desc").Find(&${className}s).Error
    if err != nil {
        return nil, 0, err
    }

    return ${className}s, total, nil
}

