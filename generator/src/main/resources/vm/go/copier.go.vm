package model

import (
"errors"
"reflect"
"strings"
"sync"
)

var (
ErrInvalidDst = errors.New("dest must be a pointer to struct")
ErrInvalidSrc = errors.New("src must be struct or pointer to struct")
)

/* =========================
Cache
========================= */

type fieldCacheKey struct {
t   reflect.Type
tag string
}

var fieldCache sync.Map // map[fieldCacheKey]map[string]fieldInfo

type fieldInfo struct {
index []int
}

/* =========================
Options
========================= */

type CopyOptions struct {
IgnoreZero bool
Fields     map[string]struct{}
Exclude    map[string]struct{}
Tag        string
}

type CopyOption func(*CopyOptions)

func WithIgnoreZero() CopyOption {
return func(o *CopyOptions) { o.IgnoreZero = true }
}

func WithTag(tag string) CopyOption {
return func(o *CopyOptions) { o.Tag = tag }
}

func WithFields(fields ...string) CopyOption {
return func(o *CopyOptions) {
o.Fields = make(map[string]struct{}, len(fields))
for _, f := range fields {
o.Fields[f] = struct{}{}
}
}
}

func WithExclude(fields ...string) CopyOption {
return func(o *CopyOptions) {
o.Exclude = make(map[string]struct{}, len(fields))
for _, f := range fields {
o.Exclude[f] = struct{}{}
}
}
}

/* =========================
Copy Entry
========================= */

func CopyAttribute(dst any, src any, opts ...CopyOption) error {
var options CopyOptions
for _, opt := range opts {
opt(&options)
}

dstVal := reflect.ValueOf(dst)
if dstVal.Kind() != reflect.Pointer || dstVal.Elem().Kind() != reflect.Struct {
return ErrInvalidDst
}
dstVal = dstVal.Elem()

srcVal := reflect.ValueOf(src)
if srcVal.Kind() == reflect.Pointer {
if srcVal.IsNil() {
return nil
}
srcVal = srcVal.Elem()
}
if srcVal.Kind() != reflect.Struct {
return ErrInvalidSrc
}

dstFields := cachedFields(dstVal.Type(), options.Tag)
srcFields := cachedFields(srcVal.Type(), options.Tag)

for name, dstInfo := range dstFields {

if options.Fields != nil {
if _, ok := options.Fields[name]; !ok {
continue
}
}
if options.Exclude != nil {
if _, ok := options.Exclude[name]; ok {
continue
}
}

srcInfo, ok := srcFields[name]
if !ok {
continue
}

dstf := dstVal.FieldByIndex(dstInfo.index)
srcf := srcVal.FieldByIndex(srcInfo.index)

if !dstf.CanSet() {
continue
}

if options.IgnoreZero && srcf.IsZero() {
continue
}

assignDeepValue(dstf, srcf)
}

return nil
}

/* =========================
Deep Assign
========================= */

func assignDeepValue(dst, src reflect.Value) {
if src.Kind() == reflect.Pointer {
if src.IsNil() {
return
}
src = src.Elem()
}

if dst.Kind() == reflect.Pointer {
if dst.IsNil() {
dst.Set(reflect.New(dst.Type().Elem()))
}
dst = dst.Elem()
}

if src.Type().AssignableTo(dst.Type()) {
dst.Set(src)
return
}

if src.Type().ConvertibleTo(dst.Type()) {
dst.Set(src.Convert(dst.Type()))
return
}

switch src.Kind() {
case reflect.Slice:
dst.Set(deepCopySlice(src, dst.Type()))
case reflect.Map:
dst.Set(deepCopyMap(src, dst.Type()))
default:
assignValue(dst, src)
}
}

func deepCopySlice(src reflect.Value, dstType reflect.Type) reflect.Value {
n := src.Len()
dst := reflect.MakeSlice(dstType, n, n)
for i := 0; i < n; i++ {
assignDeepValue(dst.Index(i), src.Index(i))
}
return dst
}

func deepCopyMap(src reflect.Value, dstType reflect.Type) reflect.Value {
dst := reflect.MakeMapWithSize(dstType, src.Len())
iter := src.MapRange()
for iter.Next() {
k := reflect.New(dstType.Key()).Elem()
v := reflect.New(dstType.Elem()).Elem()
assignDeepValue(k, iter.Key())
assignDeepValue(v, iter.Value())
dst.SetMapIndex(k, v)
}
return dst
}

/* =========================
Field Cache
========================= */

func cachedFields(t reflect.Type, tag string) map[string]fieldInfo {
key := fieldCacheKey{t: t, tag: tag}

if v, ok := fieldCache.Load(key); ok {
return v.(map[string]fieldInfo)
}

out := make(map[string]fieldInfo)
collectFields(t, tag, nil, out)

fieldCache.Store(key, out)
return out
}

func collectFields(t reflect.Type, tag string, parent []int, out map[string]fieldInfo) {
if t.Kind() == reflect.Pointer {
t = t.Elem()
}

for i := 0; i < t.NumField(); i++ {
sf := t.Field(i)

if !sf.IsExported() {
continue
}

index := append(parent, i)

// ✅ 匿名 struct / *struct 都展开
if sf.Anonymous {
ft := sf.Type
if ft.Kind() == reflect.Pointer {
ft = ft.Elem()
}
if ft.Kind() == reflect.Struct {
collectFields(ft, tag, index, out)
continue
}
}

name := sf.Name

if tag != "" {
if tv := sf.Tag.Get(tag); tv != "" && tv != "-" {
name = strings.Split(tv, ",")[0]
}
}

// 外层优先，不覆盖
if _, exists := out[name]; !exists {
out[name] = fieldInfo{index: index}
}
}
}

/*
=========================
Value Assign

=========================
*/
func assignValue(dst, src reflect.Value) {
if !src.IsValid() {
return
}

if src.Kind() == reflect.Pointer {
if src.IsNil() {
return
}
src = src.Elem()
}

if dst.Kind() == reflect.Pointer {
if dst.IsNil() {
dst.Set(reflect.New(dst.Type().Elem()))
}
dst = dst.Elem()
}

if src.Type().AssignableTo(dst.Type()) {
dst.Set(src)
return
}

if src.Type().ConvertibleTo(dst.Type()) {
dst.Set(src.Convert(dst.Type()))
return
}
}

//	MergeOption(&dest, src, Options{
//		SliceStrategy: SliceAppend,
//	})

type SliceStrategy int

const (
SliceOverride         SliceStrategy = iota // 直接覆盖
SliceAppend                                // 追加
SliceNonEmptyOverride                      // src 非空才覆盖
)

type Options struct {
SliceStrategy SliceStrategy
}

// MergeOption 将一个对象的非零值数据覆盖另一个结构体
func MergeOption(dest, src interface{}, opt Options) {
dv := reflect.ValueOf(dest)
sv := reflect.ValueOf(src)

if dv.Kind() != reflect.Ptr || dv.Elem().Kind() != reflect.Struct {
panic("dest must be pointer to struct")
}

mergeValueOption(dv.Elem(), sv, opt)
}
func mergeValueOption(dest, src reflect.Value, opt Options) {
if src.Kind() != reflect.Struct {
return
}

for i := 0; i < src.NumField(); i++ {
sf := src.Field(i)
df := dest.Field(i)

if !df.CanSet() {
continue
}

switch sf.Kind() {

case reflect.Ptr:
mergePointer(df, sf, opt)

case reflect.Struct:
mergeValueOption(df, sf, opt)

case reflect.Slice:
mergeSlice(df, sf, opt)

default:
if !sf.IsZero() {
df.Set(sf)
}
}
}
}
func mergePointer(dest, src reflect.Value, opt Options) {
if src.IsNil() {
return
}

// dest 为空，直接赋值
if dest.IsNil() {
dest.Set(src)
return
}

// 指向 struct：递归 merge
if src.Elem().Kind() == reflect.Struct {
mergeValueOption(dest.Elem(), src.Elem(), opt)
return
}

// 普通指针，直接覆盖
dest.Set(src)
}

func mergeSlice(dest, src reflect.Value, opt Options) {
if src.IsNil() {
return
}

switch opt.SliceStrategy {

case SliceOverride:
dest.Set(src)

case SliceAppend:
dest.Set(reflect.AppendSlice(dest, src))

case SliceNonEmptyOverride:
if src.Len() > 0 {
dest.Set(src)
}
default:
if src.Len() > 0 {
dest.Set(src)
}
}
}
